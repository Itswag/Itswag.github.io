<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[记录腾讯云服务器当矿机的一天]]></title>
    <url>%2Fposts%2F10207.html</url>
    <content type="text"><![CDATA[前言最近入手了一台腾讯云服务器玩玩，兴致勃勃的装上Docker，打算把之前的SpringBoot项目跑一跑。安装Docker、配置Maven Docker插件、开放Docker远程端口(这里划重点要考)、配置服务器安全组端口、编写Dockerfile文件、打包上传镜像、运行项目,一切都很正常。第二天早上，再次登录服务器时发现特别卡，下意识以为是自己运行项目的问题，初步排查一下，CPU占用100%，2M小水管带宽被占满……排查TOP命令查看进程信息TOP命令查看进程信息，可以看到“sic”这个进程内存占用非常高，下面的“masscan”进程占用也相当高(百度发现可能是扫描端口的程序)定位进程文件根据PID执行命令,ll /proc/7844,发现执行路径在 /var/tmp/sic/sic ,同目录有一个config.json文件,其内容如下图,百度一下发现各个属性像极了挖矿程序的配置 - .-查看定时任务执行crontab -l命令,发现三个异常任务,以第一个为例，corn表达式0,30 表示每0分钟和每三十分钟执行一次任务,网址返回的为一段shell脚本代码,通过管道在本地执行脚本，任务三则是每0秒(每分钟)执行一段Python脚本，任务四是腾讯云的监控组件。脚本内容大概就是通过ssh提权,删除系统日志,卸载安全组件,挖矿程序,代理服务等,然后定时执行，循环往复。总结百度一圈发现是因为Docker的远程服务没有任何加密措施，黑客可以远程直接运行任意容器,通过-v 命令(数据卷)将他的ssh公钥挂载到宿主机的/root/.ssh目录，从而实现提权。傻乎乎当了一天矿机,出于安全考虑(系统已经惨不忍睹,也无法保证没有其他暗门),我立刻更换了公网IP,并且重置了系统镜像,然后我又安装上了Docker，不同的是这次我老老实实地在本地构建了镜像~]]></content>
      <tags>
        <tag>服务器</tag>
        <tag>Docker</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大间隔数-桶排序应用]]></title>
    <url>%2Fposts%2F28e83e0e.html</url>
    <content type="text"><![CDATA[问题给定一个未排序的数组，返回其排序后的数组中相邻元素之差的最大值例：给定数组：[5,9,8,3,15]&emsp;&emsp;&emsp;排序后：[3,5,8,9,15]相邻元素之差最大的是15-9=6,结果即为6。要求:时间空间复杂度均为O(n)。代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public class MaximumGap &#123; public static int maximumGap(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return 0; &#125; int len = arr.length; int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; for (int i = 0; i &lt; len; i++) &#123; min = Math.min(min, arr[i]); max = Math.max(max, arr[i]); &#125; if (min == max) &#123; return 0; &#125; boolean book[] = new boolean[len + 1]; int maxs[] = new int[len + 1]; int mins[] = new int[len + 1]; int id = 0; for (int i = 0; i &lt; len; i++) &#123; // 划分桶号 id = (int) ((arr[i] - min) * len / (max - min)); mins[id] = book[id] ? Math.min(mins[id], arr[i]) : arr[i]; maxs[id] = book[id] ? Math.max(maxs[id], arr[i]) : arr[i]; book[id] = true; &#125; int res = 0; // 第一个桶内默认是最小值 int lastMax = maxs[0]; int i = 1; for (; i &lt;= len; i++) &#123; if (book[i]) &#123; // 两个相邻的非空桶，后一个的最小值减去前一个的最大值为相对间隔最大值 res = Math.max(res, mins[i] - lastMax); // 当前桶的最大值更新为前一个最大值 lastMax = maxs[i]; &#125; &#125; return res; &#125; public static int comparator(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return 0; &#125; Arrays.sort(arr); int gap = Integer.MIN_VALUE; for (int i = 1; i &lt; arr.length; i++) &#123; gap = Math.max(arr[i] - arr[i - 1], gap); &#125; return gap; &#125; public static int[] getRandomArray(int maxSize, int maxValue) &#123; int[] arr = new int[(int) ((maxSize + 1) * Math.random())]; for (int i = 0; i &lt; arr.length; i++) &#123; // 获取 -maxVlaue + 1 ~ maxValue 的值 arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random()); &#125; return arr; &#125; public static int[] copyArray(int[] arr) &#123; if (arr == null) &#123; return null; &#125; int[] book = new int[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; book[i] = arr[i]; &#125; return book; &#125; public static void main(String[] args) &#123; // 测试次数 int test = 50000; // 数组长度 int maxSize = 100; // 最大数值 int maxValue = 100; boolean flag = true; for (int i = 0; i &lt; test; i++) &#123; int arr1[] = getRandomArray(maxSize, maxValue); // 拷贝比较 int arr2[] = copyArray(arr1); if (maximumGap(arr1) != comparator(arr2)) &#123; flag = false; break; &#125; &#125; System.out.println(flag ? "测试正常" : "发生错误"); // 随机测试一组数据 int arr[] = getRandomArray(maxSize, maxValue); int t = maximumGap(arr); System.out.println("原数组:"+Arrays.toString(arr)); Arrays.sort(arr); System.out.println("排序后:"+Arrays.toString(arr)); System.out.println("最大差值:"+t); &#125;&#125;]]></content>
      <tags>
        <tag>桶排序</tag>
        <tag>对数器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Data JPA 映射VO/DTO对象]]></title>
    <url>%2Fposts%2F17193f90.html</url>
    <content type="text"><![CDATA[简介在项目开发中,时常需要根据业务需求来映射VO/DTO对象(这两个概念理解感觉很模糊- 。- )，本文将简单介绍以Spring Data JPA的方式处理实体类映射HQL方式123456public interface MusicTypeRepository extends JpaRepository&lt;MusicType,Integer&gt; &#123; @Query("select new cn.srblog.springbootcurd.vo.StudentTypeInfoVo(count(s.id),m.name) " + "FROM MusicType m left JOIN Student s on s.musicTypeId = m.id group by m.id ") List&lt;StudentTypeInfoVo&gt; getTypeInfo();&#125;填写实体类路径,构造参数顺序要一致,字段名一律为实体类中的属性如果配置了实体类属性的映射关系，则on s.musicTypeId = m.id语句可以省略VO实体类1234567@Valuepublic class StudentTypeInfoVo &#123; private Long count; private String name;&#125;使用Lombok的 @Value 注解默认生成带参构造方法默认为成员变量添加final修饰,且只提供getter()方法原生SQL的形式接口形式12345678910111213141516public interface CoursePlanRepository extends JpaRepository&lt;CoursePlan,Integer&gt; &#123; @Query(nativeQuery = true,value = "SELECT " + " c.id as id," + "DAYOFWEEK(c.start_time) as week," + "m.name as musicType," + "t.name as teacherName," + "c.start_time as startTime," + "c.end_time as endTime " + " FROM t_courseplan c,t_musictype m , t_teacher t " + " WHERE DATE(c.start_time) &lt; DATE_ADD(CURDATE(), INTERVAL 7 DAY ) AND CURDATE() &lt;= DATE(c.start_time) " + " and t.id=c.tea_id and c.music_type_id = m.id order by c.start_time ") List&lt;CoursePlanVos&gt; getWeekList();&#125;`nativeQuery = true 表示开启原生SQL查询查询字段别名需要与实体类中字段一一对应该方法功能为查询一周后的数据函数说明DAYOFWEEK()DAYOFWEEK函数返回日期的工作日索引值，即星期日为1，星期一为2，星期六为7。例:DAYOFWEEK(&#39;2019-05-09&#39;) 返回 5DATE()提取日期或日期/时间表达式的日期部分,格式&#39;YYYY-MM-DD&#39;或者&#39;YYYYMMDD&#39;DATE_ADD(date,INTERVAL expr unit)给日期添加指定的时间间隔。date 参数是合法的日期表达式,expr 参数是您希望添加的时间间隔,type 参数可以是MySQL支持的时间日期相关类型值CURDATE()返回当前日期 例:&#39;2019-05-09&#39;VO实体类(接口形式)1234567891011121314public interface CoursePlanVos&#123; Integer getId(); Integer getWeek(); String getMusicType(); String getTeacherName(); Date getStartTime() ; Date getEndTime();&#125;结果集形式123@Query(value = "select count(s.id) as count,m.name as name " + " FROM t_musictype m left JOIN t_student s on s.music_type_id = m.id group by m.id ",nativeQuery = true) List&lt;Object[]&gt; listType1();对比第一种方法,使用原生SQL默认会返回Object数组]]></content>
      <tags>
        <tag>Spring Data JPA</tag>
        <tag>JpaRepository</tag>
        <tag>VO</tag>
        <tag>HQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat服务器配置Https协议]]></title>
    <url>%2Fposts%2F8baea545.html</url>
    <content type="text"><![CDATA[前言日常开发项目时,一般本机都是基于http协议,但是要实现某些需求必须要开启https协议。现在https协议已经成为主流,网站如果未开启https协议,浏览器会进行安全提示。本文以Tomcat服务器为例,简单介绍如何在本机开发环境配置https协议证书生成使用JDK自带的keytool工具来生成证书库：1keytool -genkeypair -alias "tomcat" -keyalg "RSA" -keystore "d:\https\tomcat.keystore"属性说明alias证书别名keyalg加密算法,RSAkeystore证书保存路径环境设置修改Tomcat配置文件：打开Tomcat安装目录/conf/server.xml,修改如下配置,并取消注释注：这里以Tomcat8.0为例,8.5以上配置请另行百度1234&lt;Connector port="8443" protocol="org.apache.coyote.http11.Http11NioProtocol" maxThreads="150" SSLEnabled="true" scheme="https" secure="true" clientAuth="false" sslProtocol="TLS" keystoreFile="d:\https\tomcat.keystore" keystorePass="123456" /&gt;启动Tomcat1https://localhost:8443/访问链接,浏览器会提示站点不安全，点击继续访问即可(本地安装证书或者互联网申请证书解决)]]></content>
      <tags>
        <tag>Tomcat</tag>
        <tag>Https协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis批量更新的两种方式]]></title>
    <url>%2Fposts%2Fbff75e50.html</url>
    <content type="text"><![CDATA[前言在使用Mybatis框架的过程中,经常会通过构建动态SQL来处理批量插入，批量更新数据等相关操作，本文将以批量更新为例，简单介绍其使用过程动态SQL元素if set trim foreach批量更新映射方法1int updateOrderItem(List&lt;OrderItem&gt; list);实体类字段1234567public class OrderItem &#123; private Integer id; private Integer orderId; private Integer productId; private Integer count; //省略... &#125;测试代码12345678910List&lt;OrderItem&gt; list=new ArrayList&lt;&gt;();OrderItem orderItem=new OrderItem();orderItem.setCount(66);orderItem.setId(1);OrderItem orderItem1=new OrderItem();orderItem1.setCount(5);orderItem1.setId(2);list.add(orderItem);list.add(orderItem1);orderItemMapper.updateOrderItem(list);方式一1234567891011121314151617&lt;update id="updateOrderItem" parameterType="java.util.List"&gt; &lt;foreach collection="list" item="item" separator=";"&gt; update order_item &lt;set&gt; &lt;if test="item.orderId != null"&gt; order_id = #&#123;item.orderId&#125;, &lt;/if&gt; &lt;if test="item.productId != null"&gt; product_id = #&#123;item.productId&#125;, &lt;/if&gt; &lt;if test="item.count != null"&gt; count = #&#123;item.count&#125; &lt;/if&gt; &lt;/set&gt; where id = #&#123;item.id&#125; &lt;/foreach&gt;&lt;/update&gt;对应SQL:123[cn.srblog.dao.OrderItemMapper.updateOrderItem]-==&gt; Preparing: update order_item SET count = ? where id = ? ; update order_item SET count = ? where id = ? [cn.srblog.dao.OrderItemMapper.updateOrderItem]-==&gt; Parameters: 66(Integer), 1(Integer), 5(Integer), 2(Integer)[cn.srblog.dao.OrderItemMapper.updateOrderItem]-&lt;== Updates: 1此方式需要允许MySQL的一次执行多条SQL1url=jdbc:mysql://localhost:3306/ssm?characterEncoding=utf-8&amp;allowMultiQueries=true方式二1234567891011121314151617181920212223242526272829303132&lt;update id="updateOrderItem" parameterType="java.util.List"&gt; update order_item &lt;trim prefix="set" suffixOverrides=","&gt; &lt;trim prefix="orderId = case" suffix="end,"&gt; &lt;foreach collection="list" item="item"&gt; &lt;if test="item.orderId != null"&gt; when id=#&#123;item.id&#125; then #&#123;item.orderId&#125; &lt;/if&gt; &lt;/foreach&gt; &lt;/trim&gt; &lt;trim prefix="productId = case" suffix="end,"&gt; &lt;foreach collection="list" item="item"&gt; &lt;if test="item.productId != null"&gt; when id=#&#123;item.id&#125; then #&#123;item.productId&#125; &lt;/if&gt; &lt;/foreach&gt; &lt;/trim&gt; &lt;trim prefix="count = case" suffix="end,"&gt; &lt;foreach collection="list" item="item"&gt; &lt;if test="item.count != null"&gt; when id=#&#123;item.id&#125; then #&#123;item.count&#125; &lt;/if&gt; &lt;/foreach&gt; &lt;/trim&gt; &lt;/trim&gt; where id in &lt;foreach collection="idNames" index="index" item="item" open="(" separator="," close=")"&gt; &lt;if test="item.objectId != null"&gt; #&#123;item.id&#125; &lt;/if&gt; &lt;/foreach&gt; &lt;/update&gt;对应SQL123[cn.srblog.dao.OrderItemMapper.updateOrderItem]-==&gt; Preparing: update order_item set count = case when id=? then ? when id=? then ? end where id in (?,?)[cn.srblog.dao.OrderItemMapper.updateOrderItem]-==&gt; Parameters: 1(Integer), 66(Integer), 2(Integer), 5(Integer),1(Integer), 2(Integer)[cn.srblog.dao.OrderItemMapper.updateOrderItem]-&lt;== Updates: 3]]></content>
      <tags>
        <tag>Mybatis</tag>
        <tag>动态SQL</tag>
        <tag>ORM</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯-历届试题-Excel地址]]></title>
    <url>%2Fposts%2Fb1245755.html</url>
    <content type="text"><![CDATA[问题描述Excel单元格的地址表示很有趣，它使用字母来表示列号。比如，A表示第1列，B表示第2列，Z表示第26列，AA表示第27列，AB表示第28列，BA表示第53列，….当然Excel的最大列号是有限度的，所以转换起来不难。如果我们想把这种表示法一般化，可以把很大的数字转换为很长的字母序列呢？本题目即是要求对输入的数字, 输出其对应的Excel地址表示方式。样例输入26样例输出Z样例输入2054样例输出BZZ代码12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;int main()&#123; int n, i; int cont = 0; char a[100]; scanf("%d", &amp;n); while (n) &#123; if (n % 26 == 0) &#123; a[cont++] = 26 + 64; n /= 26; n--; &#125; else &#123; a[cont++] = n % 26 + 64; n /= 26; &#125; &#125; for (i = cont - 1; i &gt;= 0; i--) &#123; printf("%c", a[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>蓝桥杯</tag>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[荷兰国旗-快速排序应用]]></title>
    <url>%2Fposts%2F5644be5d.html</url>
    <content type="text"><![CDATA[荷兰国旗”荷兰国旗难题“是计算机科学中的一个程序难题，它是由Edsger Dijkstra提出的。荷兰国旗是由红、白、蓝三色组成的。现有红白蓝三个不同颜色的小球，乱序排列在一起，请重新排列这些小球，使得红白蓝三色的同颜色的球在一起。ps:我们可以将红白蓝三色小球想象成条状物，有序排列后正好组成荷兰国旗。分析arr[i]&lt; key时相当于“荷兰国旗问题”中的0arr[i]= key时相当于“荷兰国旗问题”中的1arr[i]&gt; key时相当于“荷兰国旗问题”中的2这样就可以使用“荷兰国旗问题”的解法来解决快速排序了，这样一来，即使待排序的元素中有一些元素和key一样，也能保证时间复杂度是最差是NlogN的，因为对于待排序的等于Key的数值，可以在执行下一次Partition时直接跳过，利于数据规模的降低。代码荷兰国旗12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class NetherlandsFlag &#123; public static int[] partition(int[] arr,int L,int R,int p) &#123; int less = L-1; int more = R+1; while(L &lt; more) &#123; if(arr[L] &lt; p) &#123; swap(arr,++less,L++); &#125;else if(arr[L] &gt; p) &#123; swap(arr,--more,L); &#125;else &#123; L++; &#125; &#125; return new int[] &#123;less+1,more-1&#125;; &#125; public static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; public static int[] getArray() &#123; int arr[] = new int[10]; for(int i = 0;i &lt; arr.length;i++) &#123; arr[i] = (int)(Math.random()*3); &#125; return arr; &#125; public static void printArray(int arr[]) &#123; if(arr == null) &#123; return ; &#125; for(int i = 0;i &lt; arr.length;i++) &#123; System.out.print(arr[i]+" "); &#125; System.out.println(); &#125; public static void main(String args[]) &#123; int test[] = getArray(); printArray(test); int res[] = partition(test,0,test.length-1,1); //p值为1，用来判断0，1，2 printArray(test); System.out.println(res[0]); System.out.println(res[1]); &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架结合LayUi文件上传模块接入COS对象存储服务]]></title>
    <url>%2Fposts%2F2502e0fe.html</url>
    <content type="text"><![CDATA[简介在日常项目开发中经常会用到图片，视频等文件存储的操作，但是文件如果一直存放在本地服务器中，可以会导致资源浪费，且访问速度也有所限制，这时我们就会考虑CDN加速或云端存储等方式来解决问题，这里就要介绍下本文用到的COS对象存储-安全稳定、海量、便捷、低延迟、低成本的云端存储服务。COS对象存储对象存储（Cloud Object Storage，COS）是腾讯云提供的面向非结构化数据，支持 HTTP/HTTPS 协议访问的分布式存储服务，它能容纳海量数据并保证用户对带宽和容量扩充无感知，可以作为大数据计算与分析的数据池。腾讯云 COS 提供网页端管理界面、多种语言的 SDK 以及命令行和图形化工具，并且完全兼容 S3 的 API 接口，方便用户直接使用社区工具和插件，COS 还可以和其他云产品结合，比如利用 CDN 的全球节点提供加速服务，利用数据万象的图片处理能力提供一站式图片解决方案等(详细介绍)案例实现本文使用的是腾讯云提供的COS服务，每个月提供50G存储容量，10G流量，对于一般的博客网站，以及项目测试来说绰绰有余腾讯云对象存储 COS 除了提供多种 API 接口，还提供了丰富多样的 SDK 供开发者使用，如Java、Python、Js等…，本项目后台基于SpringMVC实现，前端通过LayUi框架的文件上传模块结合实现存储桶相应的还有防盗链设置，跨域规则设置，读写权限设置，以及相应的CDN加速服务代码后台实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package cn.mall.controller.portal;import cn.mall.common.ServerResponse;import cn.mall.util.PropertiesUtil;import com.qcloud.cos.COSClient;import com.qcloud.cos.ClientConfig;import com.qcloud.cos.auth.BasicCOSCredentials;import com.qcloud.cos.auth.COSCredentials;import com.qcloud.cos.model.PutObjectRequest;import com.qcloud.cos.model.PutObjectResult;import com.qcloud.cos.region.Region;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.multipart.MultipartFile;import javax.servlet.http.HttpSession;import java.io.File;import java.io.IOException;import java.util.UUID;@Controller@RequestMapping("/upload/")public class UploadController &#123; //密钥请前往腾讯云后台查询 private static String secretId="*************"; private static String secretKey="*************"; private static String bucketName="你的存储桶名称"; private static String RegionName="存储桶所属地域"; /** * 文件上传 * @param file * @param session * @return */ @RequestMapping(value = "upload_image_cos.do",method = RequestMethod.POST) @ResponseBody public Object Upload(@RequestParam(value = "file") MultipartFile file, HttpSession session)&#123; if(file == null)&#123; return new UploadMsg(0,"文件为空",null); &#125; //获取文件上传原名 String oldFileName = file.getOriginalFilename(); String eName = oldFileName.substring(oldFileName.lastIndexOf(".")); //通过UUID随机生成新的文件名 String newFileName = UUID.randomUUID()+eName; // 1 初始化用户身份信息(secretId, secretKey) COSCredentials cred = new BasicCOSCredentials(secretId, secretKey); // 2 设置bucket的区域, COS地域的简称请参照 https://cloud.tencent.com/document/product/436/6224 ClientConfig clientConfig = new ClientConfig(new Region(RegionName)); // 3 生成cos客户端 COSClient cosclient = new COSClient(cred, clientConfig); // bucket的命名规则为&#123;name&#125;-&#123;appid&#125; ，此处填写的存储桶名称必须为此格式 String bucketName = this.bucketName; // 简单文件上传, 最大支持 5 GB, 适用于小文件上传, 建议 20 M 以下的文件使用该接口 // 大文件上传请参照 API 文档高级 API 上传 File localFile = null; try &#123; //创建临时文件 localFile = File.createTempFile("temp",null); file.transferTo(localFile); // 指定要上传到 COS 上的路径 String key = PropertiesUtil.getProperty("cos_key_name")+newFileName; PutObjectRequest putObjectRequest = new PutObjectRequest(bucketName, key, localFile); PutObjectResult putObjectResult = cosclient.putObject(putObjectRequest); return new UploadMsg(1,"上传成功", newFileName); &#125; catch (IOException e) &#123; return new UploadMsg(-1,e.getMessage(),null); &#125; finally &#123; // 关闭客户端(关闭后台线程) cosclient.shutdown(); &#125; &#125; //自定义JSON消息体 private class UploadMsg &#123; public int status; public String msg; public String path; public UploadMsg() &#123; super(); &#125; public UploadMsg(int status, String msg,String path)&#123; this.status =status; this.msg =msg; this.path =path; &#125; &#125;&#125;前台实现（完整表单）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="renderer" content="webkit"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; &lt;title&gt;商品添加&lt;/title&gt; &lt;link rel="stylesheet" href="../assets/layui/css/layui.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;form class="layui-form column-content-detail"&gt; &lt;div class="layui-tab-content"&gt; &lt;div class="layui-tab-item layui-show"&gt; &lt;div class="layui-form-item"&gt; &lt;label class="layui-form-label"&gt;商品标题：&lt;/label&gt; &lt;div class="layui-input-block"&gt; &lt;input type="text" name="name" required lay-verify="required" placeholder="请输入商品标题" autocomplete="off" class="layui-input"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="layui-form-item"&gt; &lt;label class="layui-form-label"&gt;分类：&lt;/label&gt; &lt;div class="layui-input-block"&gt; &lt;select name="categoryId" lay-verify="required"&gt; &lt;option value=""&gt;请选择分类&lt;/option&gt; &lt;option value="100001"&gt;家用电器&lt;/option&gt; &lt;option value="100002"&gt;数码3C&lt;/option&gt; &lt;option value="100003"&gt;服装箱包&lt;/option&gt; &lt;option value="100004"&gt;食品生鲜&lt;/option&gt; &lt;option value="100005"&gt;酒水饮料&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="layui-form-item"&gt; &lt;label class="layui-form-label"&gt;图像上传：&lt;/label&gt; &lt;div class="layui-input-block"&gt; &lt;img id="upload_img" src="../images/default_img.png" width="100" height="100"&gt; &lt;button type="button" class="layui-btn" id="test1"&gt; &lt;i class="layui-icon"&gt;&amp;#xe67c;&lt;/i&gt;上传图片 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="layui-form-item layui-form-text"&gt; &lt;label class="layui-form-label"&gt;商品介绍：&lt;/label&gt; &lt;div class="layui-input-block"&gt; &lt;textarea class="layui-textarea layui-hide" name="detail" lay-verify="detail" id="LAY_demo_editor"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;input type="hidden" id="mainImage" name="mainImage" required value="default_img.png" class="layui-input"&gt; &lt;input type="hidden" id="status" name="status" value="1" class="layui-input"&gt; &lt;div class="layui-form-item"&gt; &lt;label class="layui-form-label"&gt;商品库存：&lt;/label&gt; &lt;div class="layui-input-block"&gt; &lt;input type="text" name="stock" required lay-verify="number" placeholder="请输入商品库存" autocomplete="off" class="layui-input"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="layui-form-item"&gt; &lt;label class="layui-form-label"&gt;商品价格：&lt;/label&gt; &lt;div class="layui-input-block"&gt; &lt;input type="text" name="price" required lay-verify="number" placeholder="请输入商品价格" autocomplete="off" class="layui-input"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="layui-form-item" style="padding-left: 10px;"&gt; &lt;div class="layui-input-block"&gt; &lt;button class="layui-btn" lay-submit lay-filter="add_product"&gt;立即提交&lt;/button&gt; &lt;button id="reset" type="reset" class="layui-btn layui-btn-primary"&gt;重置&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt;&lt;script src="../js/cos-js-sdk-v5.min.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;&lt;script src="../js/jquery-1.10.2.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;&lt;script src="../assets/layui/layui.all.js"&gt;&lt;/script&gt;&lt;script&gt; layui.use(['form', 'jquery', 'laydate', 'layer', 'laypage', 'element', 'upload', 'layedit'], function() &#123; var form = layui.form, layer = layui.layer, $ = layui.jquery, laypage = layui.laypage, laydate = layui.laydate, layedit = layui.layedit, element = layui.element, upload=layui.upload; //创建一个编辑器 var editIndex = layedit.build('LAY_demo_editor', &#123; tool: ['strong' //加粗 , 'italic' //斜体 , 'underline' //下划线 , 'del' //删除线 , '|' //分割线 , 'left' //左对齐 , 'center' //居中对齐 , 'right' //右对齐 , 'link' //超链接 , 'unlink' //清除链接 , 'image' //插入图片 ], height: 100 &#125;); var uploadInst = upload.render(&#123; elem: '#test1' //绑定元素 ,url:'../upload/upload_image_cos.do'//后台上传接口 ,before: function(obj)&#123; //obj参数包含的信息，跟 choose回调完全一致，可参见上文。 layer.msg('上传中',&#123;icon: 16,time:0,shade:0.01&#125;); &#125; ,done: function(res, index, upload)&#123; layer.closeAll('loading'); //status=1代表上传成功 if(res.status == 1)&#123; layer.msg("上传成功",&#123;icon:1&#125;); //do something （比如将res返回的图片链接保存到表单的隐藏域） $('#upload_img').attr('src','https://sr-1251242863.cos.ap-shanghai.myqcloud.com/webdemo/images/'+res.path); $('#mainImage').val(res.path); &#125; //获取当前触发上传的元素，一般用于 elem 绑定 class 的情况，注意：此乃 layui 2.1.0 新增 var item = this.item; //文件保存失败 //do something &#125; ,error: function()&#123; layer.closeAll('loading'); //请求异常回调 layer.msg("上传失败，请重试",&#123;icon:2&#125;); &#125; ,size:2048 //文件大小限制 ,number:1 //文件数量限制 ,accept: 'images' //文件类型限制 ,acceptMime: 'image/jpg, image/png' //选择窗口属性 &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;动图演示]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>SSM框架</tag>
        <tag>COS对象存储</tag>
        <tag>LayUi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android网络编程之HttpURLConnection应用-快递查询案例]]></title>
    <url>%2Fposts%2F660e61a1.html</url>
    <content type="text"><![CDATA[前言HttpURLConnection是一种多用途、轻量极的HTTP客户端。它的API简单，体积较小，因而非常适用于Android项目，压缩和缓存机制可以有效地减少网络访问的流量，在提升速度和省电方面也起到了较大的作用，使用它来进行HTTP操作可以适用于大多数的应用程序。HttpUrlConnection是Android SDK的标准实现，直接支持系统级连接池，即打开的连接不会直接关闭，在一段时间内所有程序可共用；直接在系统层面做了缓存策略处理，加快重复请求的速度本文将以一个查询快递信息的案例来介绍，包括GET，POST两中方式请求网络资源，解析JSON数据，Handler异步消息处理机制等应用~部分代码主界面这里主要介绍GET和POST两种网络请求方式GET方式1234567891011121314151617181920212223242526272829303132333435363738private void doGet(final String params) &#123; //子线程执行网络操作 new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; URL url = new URL(URL_Source+"?type="+URLEncoder.encode(Param_DHL,"UTF-8")+"&amp;postid="+URLEncoder.encode(params,"UTF-8")); HttpURLConnection httpURLConnection = (HttpURLConnection) url.openConnection(); httpURLConnection.setRequestMethod("GET");//设置请求方式为GET httpURLConnection.setReadTimeout(3000);//设置连接超时时间 if(httpURLConnection.getResponseCode() == 200)&#123; InputStream is = httpURLConnection.getInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(is)); String line =""; StringBuffer result= new StringBuffer(); while((line = br.readLine()) != null)&#123; result.append(line); &#125; is.close(); br.close(); httpURLConnection.disconnect();//关闭连接 Message message =new Message();//创建消息体 message.what = 1; message.obj = parseData(result.toString()); handler.sendMessage(message);//发送消息体，添加到消息队列中 &#125; &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125;POST方式12345678910111213141516171819202122232425262728293031323334353637383940414243444546private void doPost(final String params) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; URL url = new URL(URL_Source); HttpURLConnection httpURLConnection = (HttpURLConnection) url.openConnection(); httpURLConnection.setConnectTimeout(3000); //设置连接超时时间 httpURLConnection.setDoInput(true); //打开输入流，以便从服务器获取数据 httpURLConnection.setDoOutput(true); //打开输出流，以便向服务器提交数据 httpURLConnection.setUseCaches(false); //禁用缓存 httpURLConnection.setRequestMethod("POST"); httpURLConnection.setRequestProperty("Content-Type","application/x-www-form-urlencoded");//设置数据编码方式 String param ="type="+URLEncoder.encode(Param_DHL,"UTF-8") +"&amp;postid="+URLEncoder.encode(params,"UTF-8"); OutputStream os = httpURLConnection.getOutputStream(); os.write(param.getBytes()); if(httpURLConnection.getResponseCode() == 200)&#123; InputStream is = httpURLConnection.getInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(is)); String line =""; StringBuffer result= new StringBuffer(); while((line = br.readLine()) != null)&#123; result.append(line); &#125; is.close(); br.close(); httpURLConnection.disconnect();//关闭连接 Message message =new Message(); message.what = 2; message.obj = parseData(result.toString()); handler.sendMessage(message); &#125; &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125;JSON数据的解析1234567891011121314151617private String parseData(String json)&#123; String result = ""; try &#123; JSONObject jsonObject = new JSONObject(json); JSONArray data = jsonObject.getJSONArray("data"); //这里只取最新的一条数据显示 if(data.length()&gt;0)&#123; result="更新时间: "+data.getJSONObject(0).getString("time")+ "\n状态: "+data.getJSONObject(0).getString("context"); &#125;else&#123; result = "该单号暂无物流进展,请稍后再试,或检查公司和单号是否有误"; &#125; &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; return result; &#125;使用Handler更新UI更新TextView123456789101112private Handler handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; if(msg.what == 1)&#123; message.setText("最新状态 (GET方式)"); info.setText(msg.obj+""); &#125;else if (msg.what == 2)&#123; message.setText("最新状态 (POST方式)"); info.setText(msg.obj+""); &#125; &#125;&#125;;动图演示项目源码等待上传中~]]></content>
      <tags>
        <tag>Android</tag>
        <tag>网络编程</tag>
        <tag>JSON</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一段Js代码开启任意网站的匿名聊天室]]></title>
    <url>%2Fposts%2Fccb2c90f.html</url>
    <content type="text"><![CDATA[简介一个&apos;神奇&apos;的在线聊天室 插件出处代码浏览器控制台输入浏览器控制台输入123var s=document.createElement('script');s.src='//topurl.cn/chat.js';document.body.append(s);地址栏输入地址栏输入1javascript:var s=document.createElement('script');s.src='//topurl.cn/chat.js';document.body.append(s);书签地址为方法2中的代码动图演示]]></content>
      <tags>
        <tag>JS</tag>
        <tag>聊天室</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS更换Yum源为阿里云源]]></title>
    <url>%2Fposts%2Fe8a99a62.html</url>
    <content type="text"><![CDATA[前言Yum仓库部署在国外，为了方便之后项目环境的部署更新操作，最好更新为国内的镜像源，本文以阿里云源为例。参考网站:https://opsx.alibaba.com/mirror步骤1.备份1mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup2.下载阿里云的源文件这里我的虚拟机版本为CentOS 7，这里根据你的版本进行操作，参考上文链接1wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo注意：这里需要给与管理员权限3.生成缓存1yum makecache结尾如果更换源后出现问题，则需要先清除默认Yum源的本地缓存1yum clean all]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Yum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android自定义Dialog对话框]]></title>
    <url>%2Fposts%2F1bd356c0.html</url>
    <content type="text"><![CDATA[前言Android项目经常需要使用对话框来进行交互，本文将介绍一个简单自定义的Dialog案例效果图代码部分自定义Dialog布局这里自由发挥，请尽情定义属于你的对话框!12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MyDialog" android:background="@drawable/dialog_layout"&gt; &lt;TextView android:id="@+id/title" android:layout_width="match_parent" android:layout_height="wrap_content" android:textColor="#000" android:text="提示" android:textStyle="bold" android:textSize="24sp" android:gravity="center" android:padding="10dp"/&gt; &lt;TextView android:id="@+id/message" android:layout_width="match_parent" android:layout_height="wrap_content" android:textSize="18sp" android:textColor="#000" android:padding="20dp" android:gravity="center" android:text="删除"/&gt; &lt;View android:layout_width="match_parent" android:layout_height="0.5dp" android:background="#000" &gt;&lt;/View&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;TextView android:padding="10dp" android:id="@+id/canel" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_weight="1" android:textColor="#11c2ee" android:textSize="24sp" android:gravity="center"/&gt; &lt;View android:layout_width="0.5dp" android:layout_height="match_parent" android:background="#000"&gt; &lt;/View&gt; &lt;TextView android:padding="10dp" android:id="@+id/confirm" android:layout_width="wrap_content" android:layout_height="wrap_content" android:textColor="#11c2ee" android:layout_weight="1" android:textSize="24sp" android:gravity="center" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;自定义Dialog背景(圆角)12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle"&gt; //内部填充色 &lt;solid android:color="#ffffff"&gt;&lt;/solid&gt; //圆角半径 &lt;corners android:radius="20dp"&gt;&lt;/corners&gt;&lt;/shape&gt;通过style样式引用更多配置属性请百度~123456789101112&lt;style name="MyDialog" parent="android:style/Theme.Dialog"&gt; &lt;!--背景颜色及和透明程度--&gt; &lt;item name="android:windowBackground"&gt;@android:color/transparent&lt;/item&gt; &lt;!--是否去除标题 --&gt; &lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt; &lt;!--是否去除边框--&gt; &lt;item name="android:windowFrame"&gt;@null&lt;/item&gt; &lt;!--是否浮现在activity之上--&gt; &lt;item name="android:windowIsFloating"&gt;true&lt;/item&gt; &lt;!--是否模糊--&gt; &lt;item name="android:backgroundDimEnabled"&gt;true&lt;/item&gt; &lt;/style&gt;自定义Dialog类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package cn.sr.alertdialogdemo;import android.app.Dialog;import android.content.Context;import android.graphics.Point;import android.support.annotation.NonNull;import android.os.Bundle;import android.view.Display;import android.view.View;import android.view.WindowManager;import android.widget.TextView;public class MyDialog extends Dialog implements View.OnClickListener&#123; private TextView mTitle,mMessage,mCanel,mConfirm; private String title,message,canel,confirm; private OnCancelListtener onCancelListtener; private OnConfirmListtener onConfirmListtener; public MyDialog setTitle(String title) &#123; this.title = title; return this; &#125; public MyDialog setMessage(String message) &#123; this.message = message; return this; &#125; public MyDialog setCanel(String canel,OnCancelListtener onCancelListtener) &#123; this.canel = canel; this.onCancelListtener = onCancelListtener; return this; &#125; public MyDialog setConfirm(String confirm,OnConfirmListtener onConfirmListtener) &#123; this.confirm = confirm; this.onConfirmListtener = onConfirmListtener; return this; &#125; public MyDialog(@NonNull Context context) &#123; super(context); &#125; public MyDialog(@NonNull Context context,int themeId) &#123; super(context,themeId); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_my_dialog); //如果对话框宽度异常，可以通过下方代码根据设备的宽度来设置弹窗宽度 WindowManager windowManager = getWindow().getWindowManager(); Display display = windowManager.getDefaultDisplay(); WindowManager.LayoutParams params = getWindow().getAttributes(); Point point=new Point(); display.getSize(point); params.width= (int) (point.x * 0.8); getWindow().setAttributes(params); mTitle=findViewById(R.id.title); mMessage=findViewById(R.id.message); mCanel=findViewById(R.id.canel); mConfirm=findViewById(R.id.confirm); mCanel.setOnClickListener(this); mConfirm.setOnClickListener(this); mTitle.setText(title); mMessage.setText(message); mCanel.setText(canel); mConfirm.setText(confirm); &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.canel: if(onCancelListtener != null)&#123; onCancelListtener.onCancel(this); &#125; dismiss(); break; case R.id.confirm: if(onConfirmListtener != null)&#123; onConfirmListtener.onConfirm(this); &#125; dismiss(); break; &#125; &#125; //自定义接口形式提供回调方法 public interface OnCancelListtener&#123; void onCancel(MyDialog myDialog); &#125; public interface OnConfirmListtener&#123; void onConfirm(MyDialog myDialog); &#125;&#125;调用演示123456789101112131415161718192021222324252627public class MainActivity extends AppCompatActivity &#123; private Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button=findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; MyDialog myDialog=new MyDialog(MainActivity.this); myDialog.setTitle("提示").setMessage("这是一个自定义的Dialog").setCanel("取消", new MyDialog.OnCancelListtener() &#123; @Override public void onCancel(MyDialog myDialog) &#123; Toast.makeText(MainActivity.this,"点击了取消按钮",Toast.LENGTH_SHORT).show(); &#125; &#125;).setConfirm("确认", new MyDialog.OnConfirmListtener() &#123; @Override public void onConfirm(MyDialog myDialog) &#123; Toast.makeText(MainActivity.this,"点击了确认按钮",Toast.LENGTH_SHORT).show(); &#125; &#125;).show(); &#125; &#125;); &#125;&#125;项目下载等待上传~]]></content>
      <tags>
        <tag>Android</tag>
        <tag>数据储存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android数据储存之SharedPreferences-记住密码案例]]></title>
    <url>%2Fposts%2Ff454cc8e.html</url>
    <content type="text"><![CDATA[简介SharedPreferences是一种轻型的数据存储方式,通过键值对的形式保存数据，存储数据是以xml文件形式存储，文件存放在/data/data//shared_prefs目录下,一般用来存储一些简单的配置信息。SharedPreferences操作模式MODE_PRIVATE：默认的操作模式，同名文件内容会被覆盖。MODE_APPEND：则表示如果该文件已存在就往文件里面追加内容，不存在就创建新文件。初始化SharedPreferencesActivity类中的getPreferences(mode)方法mode：指定操作模式默认以当前类的类名作为前缀命名文件Context类中的getSharedPreferences(name, mode)方法用于指定SharedPreferences文件的名称指定操作模式PreferenceManager类中的getDefaultSharedPreferences(context)方法静态方法，使用当前应用程序的包名作为前缀命名文件注：SharedPreferences可实现数据共享，但是无法直接在多个程序间共享，需要借助于Conttent Providers(内容分发者)SharedPreferences存储数据SharedPreferences通过Editor进行数据的编辑处理。1Editor editor=sharedPreferences.edit();存放数据以Key-Value的形式储存，只适用于一些简单的数据类型提交保存1234//后台提交，没有返回值editor.apply();//编译处理，返回Booleaneditor.commit();注：apply是将修改数据原子提交到内存,而后异步真正提交到硬件磁盘,而commit是同步的提交到硬件磁盘，因此，在多个并发的提交commit的时候，他们会等待正在处理的commit保存到磁盘后在操作，从而降低了效率。而apply只是原子的提交到内容，后面有调用apply的函数的将会直接覆盖前面的内存数据，这样从一定程度上提高了很多效率。移除数据1234//移除数据editor.remove(String key);//清空数据editor.clear();读取数据记住密码案列部分Java代码12345678910111213141516171819202122232425262728293031//XML文件的形式储存//设置本程序的私有访问 sharedPreferences=getSharedPreferences("userInfo",MODE_PRIVATE); //获取程序中已保存的信息 rememeber.setChecked(sharedPreferences.getBoolean("rememeber",false)); mName.setText(sharedPreferences.getString("name","")); mPassWord.setText(sharedPreferences.getString("password","")); mLogin.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String name=mName.getText().toString(); String password=mPassWord.getText().toString(); Editor editor=sharedPreferences.edit(); if(name.equals("admin")&amp;&amp;password.equals("admin"))&#123; //标记是否勾选记住密码 boolean flag=false; if(rememeber.isChecked())&#123; flag=true; editor.putString("name",name); editor.putString("password",password); editor.putBoolean("rememeber",true); &#125; editor.putBoolean("rememeber",flag); editor.commit(); startActivityForResult(new Intent(MainActivity.this,Main2Activity.class).putExtra("rememeber",flag),1); &#125; &#125; &#125;);下载地址: 等待上传~~]]></content>
      <tags>
        <tag>Android</tag>
        <tag>数据储存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架入门(三):依赖注入和控制反转]]></title>
    <url>%2Fposts%2F2d0cab43.html</url>
    <content type="text"><![CDATA[依赖注入和控制反转概念依赖注入(IoC) 和 控制反转(DI) 有什么关系呢？其实它们是同一个概念的不同角度描述。依赖注入(Dependency injection)是指应用在运行期，由外部容器（Spring容器）动态地将依赖对象注入到另一个对象中。理解 DI 的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”：谁依赖于谁：当然是某个容器管理对象依赖于 IoC 容器；“被注入对象的对象”依赖于“依赖对象”；为什么需要依赖：容器管理对象需要 IoC 容器来提供对象需要的外部资源；谁注入谁：很明显是 IoC 容器注入某个对象，也就是注入“依赖对象”；注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。控制反转(Inversion Of Control)IoC 容器就是具有依赖注入功能的容器，IoC 容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需直接在代码中 new 相关的对象，应用程序由 IoC 容器进行组装。在传统模式下通常有两种做法：原始做法: 调用者主动创建被依赖对象，然后再调用被依赖对象的方法。简单工厂模式: 调用者先找到被依赖对象的工厂，然后主动通过工厂去获取被依赖对象，最后再调用被依赖对象的方法。Spring容器的依赖注入设值注入：是指IoC容器通过成员变量的setter方法来注入被依赖对象。这种注入方式简单、直观，因而在Spring的依赖注入里大量使用。构造注入：利用构造器来设置依赖关系的方式，被称为构造注入。通过构造器参数对成员变量执行初始化，驱动Spring在底层以反射方式执行带指定参数的构造器。注意： 建议采用设值注入为主，构造注入为辅的注入策略。对于依赖关系无须变化的注入，尽量采用构造注入；而其他依赖关系的注入，则考虑采用设值注入。实例请自行配置，以下仅为示例代码12345678910111213&lt;!-- 通过property属性注入（必须提供set方法） --&gt;&lt;bean id="user" class="cn.sr.spring.javabean.User"&gt; &lt;property name="name" value="张三"&gt;&lt;/property&gt; &lt;property name="password" value="123456"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 通过构造函数注入 --&gt;&lt;bean id="user" class="cn.sr.spring.javabean.User"&gt; &lt;constructor-arg name="name" value="张三"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="password" value="123456"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;//除此之外还可以注入集合类型的对象，List、Set、Map、Properties……Spring容器中的Bean对于开发者来说，开发者使用Spring框架主要是做两件事：①开发Bean；②配置Bean。对于Spring框架来说，它要做的就是根据配置文件来创建Bean实例，并调用Bean实例的方法完成”依赖注入”——这就是所谓IoC的本质。容器中Bean的作用域当通过Spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下五种作用域：singleton: 单例模式，在整个Spring IoC容器中，singleton作用域的Bean将只生成一个实例。prototype: 每次通过容器的getBean()方法获取prototype作用域的Bean时，都将产生一个新的Bean实例。request: 对于一次HTTP请求，request作用域的Bean将只生成一个实例，这意味着，在同一次HTTP请求内，程序每次请求该Bean，得到的总是同一个实例。只有在Web应用中使用Spring时，该作用域才真正有效。session：该作用域将 bean 的定义限制为 HTTP 会话。 只在web-aware Spring ApplicationContext的上下文中有效。global session: 每个全局的HTTP Session对应一个Bean实例。在典型的情况下，仅在使用portlet context的时候有效，同样只在Web应用中有效。配置格式如下：1&lt;bean id="…" class="…" scope="singleton"&gt;&lt;/bean&gt;如果不指定Bean的作用域，Spring默认使用singleton作用域。prototype作用域的Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成果，就可以重复使用。因此，应该尽量避免将Bean设置成prototype作用域。创建Bean的3种方式使用构造器创建Bean实例:需要提供无参数的构造器,Spring对Bean实例的所有属性执行默认初始化，即所有的基本类型的值初始化为0或false；所有的引用类型的值初始化为null。使用静态工厂方法创建Bean:class属性须指定静态工厂类，使用factory-method属性来指定静态工厂方法，如果静态工厂方法需要参数，则使用&lt;constructor-arg…/&gt;元素指定静态工厂方法的参数。示例配置123&lt;bean id="user" class="cn.sr.spring.javabean.UserFactory" factory-mothod="getUser"&gt; &lt;constructor-arg name="name" value="张三"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;UserFactory工厂类12345678package cn.sr.spring.javabean;public class UserFactory &#123; //对应factory-method public static void getUser(String name) &#123; System.out.println("这是"+name); &#125;&#125;使用实例工厂方法创建Bean:factory-bean指定工厂实例factory-method指定实例工厂的工厂方法。若调用实例工厂方法时需要传入参数，则使用&lt;constructor-arg…/&gt;元素确定参数值。示例配置12345&lt;bean id="userFactory" class="cn.sr.spring.javabean.UserFactory" /&gt;//此时getUser方法应为非静态&lt;bean id="user" factory-bean="userFactory" factory-mothod="getUser"&gt; &lt;constructor-arg name="name" value="张三"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;Bean的生命周期这里简单的说明一下，对于作用域为prototype的Bean，Spring在仅仅负责创建Bean，每当容器创建Bean后就交给客户端的代码进行维护。但是对应singlton作用域的Bean，Spring会进行创建一次，然后整个容器中共享。所以Spring容器会负责进行跟踪其状态,负责依赖的注入和依赖实例的分配。结尾本文只是做简单介绍，个人理解方面偏多，更多有关于IOC和DI以及Bean对象的详解介绍请自行查找相关资料！]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>框架</tag>
        <tag>Java EE</tag>
        <tag>IOC</tag>
        <tag>DI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架入门(二):安装配置]]></title>
    <url>%2Fposts%2F1df93bf0.html</url>
    <content type="text"><![CDATA[下载架包这里以4.3.20版本为例，点击下载:SpringFramewoek 4.3.20版本解压缩后目录:— docs目录为api和开发文档介绍，schema目录为配置xml的schema约束文件，libs文件夹中为我们要使用的架包注意：另外还要下载spring的依赖架包: commons-logging安装1. 打开IDE工具，新建项目，导入上文下载好的架包2. 创建实体类并意添加一个方法打印输入123456789package cn.sr.spring;public class User &#123; public void isSelf() &#123; System.out.println("我是谁，我在哪，我在干什么"); &#125;&#125;3. 在src目录下 创建xml文件12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 配置javabean对象 --&gt; &lt;bean id="user" class="cn.sr.spring.User"&gt;&lt;/bean&gt;&lt;/beans&gt;4. 创建测试类123456789101112131415161718package cn.sr.spring;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.junit.*;public class TestBean &#123; @Test public void test() &#123; //通过xml文件获取Spring的上下文对象 ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml"); //通过id获取Spring管理的JavaBean对象 User user = (User) context.getBean("user"); System.out.println(user); user.isSelf(); &#125;&#125;配置完成如图所示，即配置成功。]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>框架</tag>
        <tag>Java EE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架入门(一):概念简介]]></title>
    <url>%2Fposts%2Ff9407374.html</url>
    <content type="text"><![CDATA[简介Spring 是一个开源的轻量级 Java SE（ Java 标准版本）/Java EE（ Java 企业版本）开发应用框架，其目的是用于简化企业级应用程序开发。Spring容器通过反转控制( IoC )和依赖注入( DI )来实现高内聚、低耦合的应用。除此之外它可以整合很多第三方框架，它还提供面向切面编程（ AOP ）的能力，对通用任务如安全、事务、日志等进行集中式管理概念介绍框架：能完成一定功能的半成品，比如我们可以使用框架进行购物网站开发；框架做一部分功能，我们自己做一部分功能，辅助高效工作。而且框架规定了你在开发应用程序时的整体架构，提供了一些基础功能，还规定了类和对象的如何创建、如何协作等，从而简化我们的代码编写，让我们专注于业务逻辑开发。非侵入式设计：从框架角度可以这样理解，无需继承框架提供的类，这种设计就可以看作是非侵入式设计，如果继承了这些框架类，就是侵入设计，如果以后想更换框架，之前写过的代码几乎无法重用，如果非侵入式设计则之前写过的代码仍然可以继续使用。轻量级与重量级：轻量级是相对于重量级而言的，轻量级一般就是非入侵性的、所依赖的东西非常少、资源占用非常少、部署简单等等，其实就是比较容易使用，而重量级正好相反。POJO ： POJO （ Plain Ordinary Java Object ）简单的 Java 对象。它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其它 Java 框架的类或接口。容器：在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是装对象的的对象，因为存在放入、拿出等操作，所以容器还要管理对象的生命周期。控制反转：即 Inversion of Control ，缩写为 IoC ，控制反转还有一个名字叫做依赖注入（ Dependency Injection ），就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。Bean ：一般指容器管理对象，在 Spring 中指 Spring IoC 容器管理对象。优点低侵入式设计，代码的污染极低。独立于各种应用服务器，基于Spring框架的应用，可以真正实现Write Once，Run Anywhere的承诺。Spring的IoC容器降低了业务对象替换的复杂性，提高了组件之间的解耦。Spring的AOP支持允许将一些通用任务如安全、事务、日志等进行集中式管理，从而提供了更好的复用。Spring的ORM和DAO提供了与第三方持久层框架的良好整合，并简化了底层的数据库访问。Spring的高度开放性，并不强制应用完全依赖于Spring，开发者可自由选用Spring框架的部分或全部。架构图核心容器：包括 Core 、 Beans 、 Context 、 EL 模块Core 模块：封装了框架依赖的最底层部分，包括资源访问、类型转换及一些常用工具类。Beans 模块：提供了框架的基础部分，包括控制反转（ IOC ）和依赖注入（ DI ）。其中 BeanFactory 是容器核心，本质是“工厂设计模式”的实现，而且无需编程实现“单例设计模式”，单例完全由容器控制，而且提倡面向接口编程，而非面向实现编程；所有应用程序对象及对象间关系由框架管理，从而真正从程序逻辑中把维护对象之间的依赖关系提取出来，所有这些依赖关系都由 BeanFactory 来维护。Context 模块：以 Core 和 Beans 为基础，集成 Beans 模块功能并添加资源绑定、数据验证、国际化、 Java EE 支持、容器生命周期、事件传播等；核心接口是 ApplicationContext 。EL 模块：提供强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从 Spring 容器获取 Bean， 它也支持列表投影、选择和一般的列表聚合等。AOP 模块： Spring AOP 模块提供了符合 AOP Alliance 规范的面向切面的编程（ aspect-oriented programming ）实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中；这样各专其职，降低业务逻辑和通用功能的耦合。-Aspects 模块：提供了对 AspectJ 的集成，AspectJ 提供了比 Spring ASP 更强大的功能。数据访问/集成模块：该模块包括了 JDBC 、 ORM 、 OXM 、 JMS 和事务管理。事务模块：该模块用于 Spring 管理事务，只要是 Spring 管理对象都能得到 Spring 管理事务的好处，无需在代码中进行事务控制了，而且支持编程和声明性的事务管理。JDBC 模块：提供了一个 JBDC 的样例模板，使用这些模板能消除传统冗长的 JDBC 编码还有必须的事务控制，而且能享受到 Spring 管理事务的好处。ORM 模块：提供与流行的“对象-关系”映射框架的无缝集成，包括 Hibernate 、JPA 、 MyBatis 等。而且可以使用 Spring 事务管理，无需额外控制事务。OXM 模块：提供了一个对 Object / XML 映射实现，将 java 对象映射成 XML 数据，或者将 XML 数据映射成 java 对象， Object / XML 映射实现包括 JAXB 、 Castor 、 XMLBeans 和 XStream 。JMS 模块：用于 JMS ( Java Messaging Service )，提供一套 “消息生产者、消息消费者”模板用于更加简单的使用 JMS ， JMS 用于用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Web / Remoting 模块： Web / Remoting 模块包含了 Web 、 Web-Servlet 、 Web-Struts 、 Web-Porlet 模块。Web 模块：提供了基础的 web 功能。例如多文件上传、集成 IoC 容器、远程过程访问（ RMI 、Hessian 、 Burlap ）以及 Web Service 支持，并提供一个 RestTemplate 类来提供方便的 Restful services 访问。Web-Servlet 模块：提供了一个 Spring MVC Web 框架实现。Spring MVC 框架提供了基于注解的请求资源注入、更简单的数据绑定、数据验证等及一套非常易用的 JSP 标签，完全无缝与 Spring 其他技术协作。Web-Struts 模块：提供了与 Struts 无缝集成， Struts1.x 和 Struts2.x 都支持。Test 模块： Spring 支持 Junit 和 TestNG 测试框架，而且还额外提供了一些基于 Spring 的测试功能，比如在测试 Web 框架时，模拟 Http 请求的功能。]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>框架</tag>
        <tag>Java EE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fposts%2F4a17b156.html</url>
    <content type="text"><![CDATA[永远相信美好的事情即将发生~]]></content>
  </entry>
</search>
